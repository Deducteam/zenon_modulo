# species_general_set: lt_is_not_leq

#    (* to be proved *)
#(x: abst_T) (y: abst_T)
#(and
#  ((Is_true ((abst_lt  x y)) ))-> 
#    (and (Is_true ((abst_leq  x y)) ) (Is_true ((abst_different  x y)) ))
#  ((Is_true ((abst_leq  x y)) ))-> 
#    (or (Is_true ((abst_lt  x y)) ) (Is_true ((abst_equal  x y)) )))
#By 
#By def
#      abst_different:= [x: abst_T][y: abst_T](not_b  (abst_equal  x y))
#      abst_lt:= [x: abst_T][y: abst_T](and_b  (abst_leq  x y) (not_b 
#      (abst_equal  x y)))
#(* Qed *).

$goal (A. ((x "abst_T") (A. ((y "abst_T")
        (/\ (=> (Is_true (abst_lt x y))
                (/\ (Is_true (abst_leq x y)) (Is_true (abst_different x y))))
            (=> (Is_true (abst_leq x y))
                (\/ (Is_true (abst_lt x y)) (Is_true (abst_equal x y)))))))))

$def abst_different (x y) (not_b (abst_equal x y))
$def abst_lt (x y) (and_b (abst_leq x y) (not_b (abst_equal x y)))


# theorems that should be integrated in the prover somehow
# (lifting boolean operators into connectives)

;$2 (A. ((x) (<=> (Is_true (not_b x)) (-. (Is_true x)))))
;$2 (A. ((x) (A. ((y)
;     (<=> (Is_true (and_b x y)) (/\ (Is_true x) (Is_true y)))))))

#NAME CSR004_432todk.
tapOff : logic.Term.
holdsAt : logic.Term -> logic.Term -> logic.Prop.
n4 : logic.Term.
less_or_equal : logic.Term -> logic.Term -> logic.Prop.
tapOn : logic.Term.
n3 : logic.Term.
n5 : logic.Term.
n2 : logic.Term.
startedIn : logic.Term -> logic.Term -> logic.Term -> logic.Prop.
overflow : logic.Term.
stoppedIn : logic.Term -> logic.Term -> logic.Term -> logic.Prop.
n1 : logic.Term.
waterLevel : logic.Term -> logic.Term.
spilling : logic.Term.
plus : logic.Term -> logic.Term -> logic.Term.
less : logic.Term -> logic.Term -> logic.Prop.
n8 : logic.Term.
n6 : logic.Term.
trajectory : logic.Term -> logic.Term -> logic.Term -> logic.Term -> logic.Prop.
terminates : logic.Term -> logic.Term -> logic.Term -> logic.Prop.
initiates : logic.Term -> logic.Term -> logic.Term -> logic.Prop.
antitrajectory : logic.Term -> logic.Term -> logic.Term -> logic.Term -> logic.Prop.
releases : logic.Term -> logic.Term -> logic.Term -> logic.Prop.
n9 : logic.Term.
filling : logic.Term.
happens : logic.Term -> logic.Term -> logic.Prop.
releasedAt : logic.Term -> logic.Term -> logic.Prop.
n7 : logic.Term.
n0 : logic.Term.
conjecture_proof : (logic.prf (logic.imply (logic.forall (Time1: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Time2: logic.Term => (logic.equiv (stoppedIn Time1 Fluent Time2) (logic.exists (Event: logic.Term => (logic.exists (Time: logic.Term => (logic.and (happens Event Time) (logic.and (less Time1 Time) (logic.and (less Time Time2) (terminates Event Fluent Time))))))))))))))) (logic.imply (logic.forall (Time1: logic.Term => (logic.forall (Time2: logic.Term => (logic.forall (Fluent: logic.Term => (logic.equiv (startedIn Time1 Fluent Time2) (logic.exists (Event: logic.Term => (logic.exists (Time: logic.Term => (logic.and (happens Event Time) (logic.and (less Time1 Time) (logic.and (less Time Time2) (initiates Event Fluent Time))))))))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Fluent2: logic.Term => (logic.forall (Offset: logic.Term => (logic.imply (logic.and (happens Event Time) (logic.and (initiates Event Fluent Time) (logic.and (less (n0) Offset) (logic.and (trajectory Fluent Time Fluent2 Offset) (logic.not (stoppedIn Time Fluent (plus Time Offset))))))) (holdsAt Fluent2 (plus Time Offset))))))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Time1: logic.Term => (logic.forall (Fluent1: logic.Term => (logic.forall (Time2: logic.Term => (logic.forall (Fluent2: logic.Term => (logic.imply (logic.and (happens Event Time1) (logic.and (terminates Event Fluent1 Time1) (logic.and (less (n0) Time2) (logic.and (antitrajectory Fluent1 Time1 Fluent2 Time2) (logic.not (startedIn Time1 Fluent1 (plus Time1 Time2))))))) (holdsAt Fluent2 (plus Time1 Time2))))))))))))) (logic.imply (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.imply (logic.and (holdsAt Fluent Time) (logic.and (logic.not (releasedAt Fluent (plus Time (n1)))) (logic.not (logic.exists (Event: logic.Term => (logic.and (happens Event Time) (terminates Event Fluent Time))))))) (holdsAt Fluent (plus Time (n1)))))))) (logic.imply (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.imply (logic.and (logic.not (holdsAt Fluent Time)) (logic.and (logic.not (releasedAt Fluent (plus Time (n1)))) (logic.not (logic.exists (Event: logic.Term => (logic.and (happens Event Time) (initiates Event Fluent Time))))))) (logic.not (holdsAt Fluent (plus Time (n1))))))))) (logic.imply (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.imply (logic.and (releasedAt Fluent Time) (logic.not (logic.exists (Event: logic.Term => (logic.and (happens Event Time) (logic.or (initiates Event Fluent Time) (terminates Event Fluent Time))))))) (releasedAt Fluent (plus Time (n1)))))))) (logic.imply (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.imply (logic.and (logic.not (releasedAt Fluent Time)) (logic.not (logic.exists (Event: logic.Term => (logic.and (happens Event Time) (releases Event Fluent Time)))))) (logic.not (releasedAt Fluent (plus Time (n1))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.imply (logic.and (happens Event Time) (initiates Event Fluent Time)) (holdsAt Fluent (plus Time (n1)))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.imply (logic.and (happens Event Time) (terminates Event Fluent Time)) (logic.not (holdsAt Fluent (plus Time (n1))))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.imply (logic.and (happens Event Time) (releases Event Fluent Time)) (releasedAt Fluent (plus Time (n1)))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.imply (logic.and (happens Event Time) (logic.or (initiates Event Fluent Time) (terminates Event Fluent Time))) (logic.not (releasedAt Fluent (plus Time (n1))))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.equiv (initiates Event Fluent Time) (logic.or (logic.and (logic.equal Event (tapOn)) (logic.equal Fluent (filling))) (logic.or (logic.and (logic.equal Event (overflow)) (logic.equal Fluent (spilling))) (logic.or (logic.exists (Height: logic.Term => (logic.and (holdsAt (waterLevel Height) Time) (logic.and (logic.equal Event (tapOff)) (logic.equal Fluent (waterLevel Height)))))) (logic.exists (Height: logic.Term => (logic.and (holdsAt (waterLevel Height) Time) (logic.and (logic.equal Event (overflow)) (logic.equal Fluent (waterLevel Height)))))))))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.equiv (terminates Event Fluent Time) (logic.or (logic.and (logic.equal Event (tapOff)) (logic.equal Fluent (filling))) (logic.and (logic.equal Event (overflow)) (logic.equal Fluent (filling))))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.equiv (releases Event Fluent Time) (logic.exists (Height: logic.Term => (logic.and (logic.equal Event (tapOn)) (logic.equal Fluent (waterLevel Height)))))))))))) (logic.imply (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.equiv (happens Event Time) (logic.or (logic.and (logic.equal Event (tapOn)) (logic.equal Time (n0))) (logic.and (holdsAt (waterLevel (n3)) Time) (logic.and (holdsAt (filling) Time) (logic.equal Event (overflow)))))))))) (logic.imply (logic.forall (Height1: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Height2: logic.Term => (logic.forall (Offset: logic.Term => (logic.imply (logic.and (holdsAt (waterLevel Height1) Time) (logic.equal Height2 (plus Height1 Offset))) (trajectory (filling) Time (waterLevel Height2) Offset)))))))))) (logic.imply (logic.forall (Time: logic.Term => (logic.forall (Height1: logic.Term => (logic.forall (Height2: logic.Term => (logic.imply (logic.and (holdsAt (waterLevel Height1) Time) (holdsAt (waterLevel Height2) Time)) (logic.equal Height1 Height2)))))))) (logic.imply (logic.not (logic.equal (tapOff) (tapOn))) (logic.imply (logic.not (logic.equal (tapOff) (overflow))) (logic.imply (logic.not (logic.equal (overflow) (tapOn))) (logic.imply (logic.forall (X: logic.Term => (logic.not (logic.equal (filling) (waterLevel X))))) (logic.imply (logic.forall (X: logic.Term => (logic.not (logic.equal (spilling) (waterLevel X))))) (logic.imply (logic.not (logic.equal (filling) (spilling))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.equiv (logic.equal (waterLevel X) (waterLevel Y)) (logic.equal X Y)))))) (logic.imply (logic.equal (plus (n0) (n0)) (n0)) (logic.imply (logic.equal (plus (n0) (n1)) (n1)) (logic.imply (logic.equal (plus (n0) (n2)) (n2)) (logic.imply (logic.equal (plus (n0) (n3)) (n3)) (logic.imply (logic.equal (plus (n1) (n1)) (n2)) (logic.imply (logic.equal (plus (n1) (n2)) (n3)) (logic.imply (logic.equal (plus (n1) (n3)) (n4)) (logic.imply (logic.equal (plus (n2) (n2)) (n4)) (logic.imply (logic.equal (plus (n2) (n3)) (n5)) (logic.imply (logic.equal (plus (n3) (n3)) (n6)) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.equal (plus X Y) (plus Y X)))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.equiv (less_or_equal X Y) (logic.or (less X Y) (logic.equal X Y))))))) (logic.imply (logic.not (logic.exists (X: logic.Term => (less X (n0))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (less X (n1)) (less_or_equal X (n0))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (less X (n2)) (less_or_equal X (n1))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (less X (n3)) (less_or_equal X (n2))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (less X (n4)) (less_or_equal X (n3))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (less X (n5)) (less_or_equal X (n4))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (less X (n6)) (less_or_equal X (n5))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (less X (n7)) (less_or_equal X (n6))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (less X (n8)) (less_or_equal X (n7))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (less X (n9)) (less_or_equal X (n8))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.equiv (less X Y) (logic.and (logic.not (less Y X)) (logic.not (logic.equal Y X)))))))) (logic.imply (holdsAt (waterLevel (n0)) (n0)) (logic.imply (logic.not (holdsAt (filling) (n0))) (logic.imply (logic.not (holdsAt (spilling) (n0))) (logic.imply (logic.forall (Height: logic.Term => (logic.not (releasedAt (waterLevel Height) (n0))))) (logic.imply (logic.not (releasedAt (filling) (n0))) (logic.imply (logic.not (releasedAt (spilling) (n0))) (logic.imply (holdsAt (waterLevel (n3)) (n3)) (logic.imply (holdsAt (filling) (n3)) (logic.not (logic.not (happens (overflow) (n3))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :=
(H0 : (logic.prf (logic.forall (Time1: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Time2: logic.Term => (logic.equiv (stoppedIn Time1 Fluent Time2) (logic.exists (Event: logic.Term => (logic.exists (Time: logic.Term => (logic.and (happens Event Time) (logic.and (less Time1 Time) (logic.and (less Time Time2) (terminates Event Fluent Time)))))))))))))))) => (H1 : (logic.prf (logic.forall (Time1: logic.Term => (logic.forall (Time2: logic.Term => (logic.forall (Fluent: logic.Term => (logic.equiv (startedIn Time1 Fluent Time2) (logic.exists (Event: logic.Term => (logic.exists (Time: logic.Term => (logic.and (happens Event Time) (logic.and (less Time1 Time) (logic.and (less Time Time2) (initiates Event Fluent Time)))))))))))))))) => (H2 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Fluent2: logic.Term => (logic.forall (Offset: logic.Term => (logic.imply (logic.and (happens Event Time) (logic.and (initiates Event Fluent Time) (logic.and (less (n0) Offset) (logic.and (trajectory Fluent Time Fluent2 Offset) (logic.not (stoppedIn Time Fluent (plus Time Offset))))))) (holdsAt Fluent2 (plus Time Offset)))))))))))))) => (H3 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Time1: logic.Term => (logic.forall (Fluent1: logic.Term => (logic.forall (Time2: logic.Term => (logic.forall (Fluent2: logic.Term => (logic.imply (logic.and (happens Event Time1) (logic.and (terminates Event Fluent1 Time1) (logic.and (less (n0) Time2) (logic.and (antitrajectory Fluent1 Time1 Fluent2 Time2) (logic.not (startedIn Time1 Fluent1 (plus Time1 Time2))))))) (holdsAt Fluent2 (plus Time1 Time2)))))))))))))) => (H4 : (logic.prf (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.imply (logic.and (holdsAt Fluent Time) (logic.and (logic.not (releasedAt Fluent (plus Time (n1)))) (logic.not (logic.exists (Event: logic.Term => (logic.and (happens Event Time) (terminates Event Fluent Time))))))) (holdsAt Fluent (plus Time (n1))))))))) => (H5 : (logic.prf (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.imply (logic.and (logic.not (holdsAt Fluent Time)) (logic.and (logic.not (releasedAt Fluent (plus Time (n1)))) (logic.not (logic.exists (Event: logic.Term => (logic.and (happens Event Time) (initiates Event Fluent Time))))))) (logic.not (holdsAt Fluent (plus Time (n1)))))))))) => (H6 : (logic.prf (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.imply (logic.and (releasedAt Fluent Time) (logic.not (logic.exists (Event: logic.Term => (logic.and (happens Event Time) (logic.or (initiates Event Fluent Time) (terminates Event Fluent Time))))))) (releasedAt Fluent (plus Time (n1))))))))) => (H7 : (logic.prf (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.imply (logic.and (logic.not (releasedAt Fluent Time)) (logic.not (logic.exists (Event: logic.Term => (logic.and (happens Event Time) (releases Event Fluent Time)))))) (logic.not (releasedAt Fluent (plus Time (n1)))))))))) => (H8 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.imply (logic.and (happens Event Time) (initiates Event Fluent Time)) (holdsAt Fluent (plus Time (n1))))))))))) => (H9 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.imply (logic.and (happens Event Time) (terminates Event Fluent Time)) (logic.not (holdsAt Fluent (plus Time (n1)))))))))))) => (H10 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.imply (logic.and (happens Event Time) (releases Event Fluent Time)) (releasedAt Fluent (plus Time (n1))))))))))) => (H11 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Fluent: logic.Term => (logic.imply (logic.and (happens Event Time) (logic.or (initiates Event Fluent Time) (terminates Event Fluent Time))) (logic.not (releasedAt Fluent (plus Time (n1)))))))))))) => (H12 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.equiv (initiates Event Fluent Time) (logic.or (logic.and (logic.equal Event (tapOn)) (logic.equal Fluent (filling))) (logic.or (logic.and (logic.equal Event (overflow)) (logic.equal Fluent (spilling))) (logic.or (logic.exists (Height: logic.Term => (logic.and (holdsAt (waterLevel Height) Time) (logic.and (logic.equal Event (tapOff)) (logic.equal Fluent (waterLevel Height)))))) (logic.exists (Height: logic.Term => (logic.and (holdsAt (waterLevel Height) Time) (logic.and (logic.equal Event (overflow)) (logic.equal Fluent (waterLevel Height))))))))))))))))) => (H13 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.equiv (terminates Event Fluent Time) (logic.or (logic.and (logic.equal Event (tapOff)) (logic.equal Fluent (filling))) (logic.and (logic.equal Event (overflow)) (logic.equal Fluent (filling)))))))))))) => (H14 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Fluent: logic.Term => (logic.forall (Time: logic.Term => (logic.equiv (releases Event Fluent Time) (logic.exists (Height: logic.Term => (logic.and (logic.equal Event (tapOn)) (logic.equal Fluent (waterLevel Height))))))))))))) => (H15 : (logic.prf (logic.forall (Event: logic.Term => (logic.forall (Time: logic.Term => (logic.equiv (happens Event Time) (logic.or (logic.and (logic.equal Event (tapOn)) (logic.equal Time (n0))) (logic.and (holdsAt (waterLevel (n3)) Time) (logic.and (holdsAt (filling) Time) (logic.equal Event (overflow))))))))))) => (H16 : (logic.prf (logic.forall (Height1: logic.Term => (logic.forall (Time: logic.Term => (logic.forall (Height2: logic.Term => (logic.forall (Offset: logic.Term => (logic.imply (logic.and (holdsAt (waterLevel Height1) Time) (logic.equal Height2 (plus Height1 Offset))) (trajectory (filling) Time (waterLevel Height2) Offset))))))))))) => (H17 : (logic.prf (logic.forall (Time: logic.Term => (logic.forall (Height1: logic.Term => (logic.forall (Height2: logic.Term => (logic.imply (logic.and (holdsAt (waterLevel Height1) Time) (holdsAt (waterLevel Height2) Time)) (logic.equal Height1 Height2))))))))) => (H18 : (logic.prf (logic.not (logic.equal (tapOff) (tapOn)))) => (H19 : (logic.prf (logic.not (logic.equal (tapOff) (overflow)))) => (H20 : (logic.prf (logic.not (logic.equal (overflow) (tapOn)))) => (H21 : (logic.prf (logic.forall (X: logic.Term => (logic.not (logic.equal (filling) (waterLevel X)))))) => (H22 : (logic.prf (logic.forall (X: logic.Term => (logic.not (logic.equal (spilling) (waterLevel X)))))) => (H23 : (logic.prf (logic.not (logic.equal (filling) (spilling)))) => (H24 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.equiv (logic.equal (waterLevel X) (waterLevel Y)) (logic.equal X Y))))))) => (H25 : (logic.prf (logic.equal (plus (n0) (n0)) (n0))) => (H26 : (logic.prf (logic.equal (plus (n0) (n1)) (n1))) => (H27 : (logic.prf (logic.equal (plus (n0) (n2)) (n2))) => (H28 : (logic.prf (logic.equal (plus (n0) (n3)) (n3))) => (H29 : (logic.prf (logic.equal (plus (n1) (n1)) (n2))) => (H30 : (logic.prf (logic.equal (plus (n1) (n2)) (n3))) => (H31 : (logic.prf (logic.equal (plus (n1) (n3)) (n4))) => (H32 : (logic.prf (logic.equal (plus (n2) (n2)) (n4))) => (H33 : (logic.prf (logic.equal (plus (n2) (n3)) (n5))) => (H34 : (logic.prf (logic.equal (plus (n3) (n3)) (n6))) => (H35 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.equal (plus X Y) (plus Y X))))))) => (H36 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.equiv (less_or_equal X Y) (logic.or (less X Y) (logic.equal X Y)))))))) => (H37 : (logic.prf (logic.not (logic.exists (X: logic.Term => (less X (n0)))))) => (H38 : (logic.prf (logic.forall (X: logic.Term => (logic.equiv (less X (n1)) (less_or_equal X (n0)))))) => (H39 : (logic.prf (logic.forall (X: logic.Term => (logic.equiv (less X (n2)) (less_or_equal X (n1)))))) => (H40 : (logic.prf (logic.forall (X: logic.Term => (logic.equiv (less X (n3)) (less_or_equal X (n2)))))) => (H41 : (logic.prf (logic.forall (X: logic.Term => (logic.equiv (less X (n4)) (less_or_equal X (n3)))))) => (H42 : (logic.prf (logic.forall (X: logic.Term => (logic.equiv (less X (n5)) (less_or_equal X (n4)))))) => (H43 : (logic.prf (logic.forall (X: logic.Term => (logic.equiv (less X (n6)) (less_or_equal X (n5)))))) => (H44 : (logic.prf (logic.forall (X: logic.Term => (logic.equiv (less X (n7)) (less_or_equal X (n6)))))) => (H45 : (logic.prf (logic.forall (X: logic.Term => (logic.equiv (less X (n8)) (less_or_equal X (n7)))))) => (H46 : (logic.prf (logic.forall (X: logic.Term => (logic.equiv (less X (n9)) (less_or_equal X (n8)))))) => (H47 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.equiv (less X Y) (logic.and (logic.not (less Y X)) (logic.not (logic.equal Y X))))))))) => (H48 : (logic.prf (holdsAt (waterLevel (n0)) (n0))) => (H49 : (logic.prf (logic.not (holdsAt (filling) (n0)))) => (H50 : (logic.prf (logic.not (holdsAt (spilling) (n0)))) => (H51 : (logic.prf (logic.forall (Height: logic.Term => (logic.not (releasedAt (waterLevel Height) (n0)))))) => (H52 : (logic.prf (logic.not (releasedAt (filling) (n0)))) => (H53 : (logic.prf (logic.not (releasedAt (spilling) (n0)))) => (H54 : (logic.prf (holdsAt (waterLevel (n3)) (n3))) => (H55 : (logic.prf (holdsAt (filling) (n3))) => (((H15 (overflow)) (n3)) (logic.not (logic.not (happens (overflow) (n3)))) (H56 : (logic.prf (logic.imply (happens (overflow) (n3)) (logic.or (logic.and (logic.equal (overflow) (tapOn)) (logic.equal (n3) (n0))) (logic.and (holdsAt (waterLevel (n3)) (n3)) (logic.and (holdsAt (filling) (n3)) (logic.equal (overflow) (overflow))))))) => H57 : (logic.prf (logic.imply (logic.or (logic.and (logic.equal (overflow) (tapOn)) (logic.equal (n3) (n0))) (logic.and (holdsAt (waterLevel (n3)) (n3)) (logic.and (holdsAt (filling) (n3)) (logic.equal (overflow) (overflow))))) (happens (overflow) (n3)))) => (H58 : (logic.prf (logic.not (happens (overflow) (n3)))) => (H58 (H57 (H56 ((H58 (H57 (P59 : logic.Prop => H60 : ((logic.prf (logic.and (logic.equal (overflow) (tapOn)) (logic.equal (n3) (n0)))) -> logic.prf P59) => H61 : ((logic.prf (logic.and (holdsAt (waterLevel (n3)) (n3)) (logic.and (holdsAt (filling) (n3)) (logic.equal (overflow) (overflow))))) -> logic.prf P59) => H61 (P62 : logic.Prop => H63 : ((logic.prf (holdsAt (waterLevel (n3)) (n3))) -> (logic.prf (logic.and (holdsAt (filling) (n3)) (logic.equal (overflow) (overflow)))) -> logic.prf P62) => H63 H54 (P64 : logic.Prop => H65 : ((logic.prf (holdsAt (filling) (n3))) -> (logic.prf (logic.equal (overflow) (overflow))) -> logic.prf P64) => H65 H55 (P66 : (logic.Term -> logic.Prop) => (H67 : (logic.prf (P66 (overflow))) => H67))))))) (happens (overflow) (n3))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))).
#NAME GEO172_431todk.
distinct_lines : logic.Term -> logic.Term -> logic.Prop.
convergent_lines : logic.Term -> logic.Term -> logic.Prop.
line_connecting : logic.Term -> logic.Term -> logic.Term.
intersection_point : logic.Term -> logic.Term -> logic.Term.
distinct_points : logic.Term -> logic.Term -> logic.Prop.
apart_point_and_line : logic.Term -> logic.Term -> logic.Prop.
conjecture_proof : (logic.prf (logic.imply (logic.forall (X: logic.Term => (logic.not (distinct_points X X)))) (logic.imply (logic.forall (X: logic.Term => (logic.not (distinct_lines X X)))) (logic.imply (logic.forall (X: logic.Term => (logic.not (convergent_lines X X)))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (distinct_points X Y) (logic.or (distinct_points X Z) (distinct_points Y Z))))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (distinct_lines X Y) (logic.or (distinct_lines X Z) (distinct_lines Y Z))))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (convergent_lines X Y) (logic.or (convergent_lines X Z) (convergent_lines Y Z))))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.imply (distinct_points X Y) (logic.not (apart_point_and_line X (line_connecting X Y)))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.imply (distinct_points X Y) (logic.not (apart_point_and_line Y (line_connecting X Y)))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.imply (convergent_lines X Y) (logic.not (apart_point_and_line (intersection_point X Y) X))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.imply (convergent_lines X Y) (logic.not (apart_point_and_line (intersection_point X Y) Y))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (U: logic.Term => (logic.forall (V: logic.Term => (logic.imply (logic.and (distinct_points X Y) (distinct_lines U V)) (logic.or (apart_point_and_line X U) (logic.or (apart_point_and_line X V) (logic.or (apart_point_and_line Y U) (apart_point_and_line Y V))))))))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (apart_point_and_line X Y) (logic.or (distinct_points X Z) (apart_point_and_line Z Y))))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (apart_point_and_line X Y) (logic.or (distinct_lines Y Z) (apart_point_and_line X Z))))))))) (logic.imply (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (convergent_lines X Y) (logic.or (distinct_lines Y Z) (convergent_lines X Z))))))))) (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (logic.and (convergent_lines X Y) (logic.and (logic.not (apart_point_and_line Z X)) (logic.not (apart_point_and_line Z Y)))) (logic.not (distinct_points Z (intersection_point X Y))))))))))))))))))))))))) :=
(H0 : (logic.prf (logic.forall (X: logic.Term => (logic.not (distinct_points X X))))) => (H1 : (logic.prf (logic.forall (X: logic.Term => (logic.not (distinct_lines X X))))) => (H2 : (logic.prf (logic.forall (X: logic.Term => (logic.not (convergent_lines X X))))) => (H3 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (distinct_points X Y) (logic.or (distinct_points X Z) (distinct_points Y Z)))))))))) => (H4 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (distinct_lines X Y) (logic.or (distinct_lines X Z) (distinct_lines Y Z)))))))))) => (H5 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (convergent_lines X Y) (logic.or (convergent_lines X Z) (convergent_lines Y Z)))))))))) => (H6 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.imply (distinct_points X Y) (logic.not (apart_point_and_line X (line_connecting X Y))))))))) => (H7 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.imply (distinct_points X Y) (logic.not (apart_point_and_line Y (line_connecting X Y))))))))) => (H8 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.imply (convergent_lines X Y) (logic.not (apart_point_and_line (intersection_point X Y) X)))))))) => (H9 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.imply (convergent_lines X Y) (logic.not (apart_point_and_line (intersection_point X Y) Y)))))))) => (H10 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (U: logic.Term => (logic.forall (V: logic.Term => (logic.imply (logic.and (distinct_points X Y) (distinct_lines U V)) (logic.or (apart_point_and_line X U) (logic.or (apart_point_and_line X V) (logic.or (apart_point_and_line Y U) (apart_point_and_line Y V)))))))))))))) => (H11 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (apart_point_and_line X Y) (logic.or (distinct_points X Z) (apart_point_and_line Z Y)))))))))) => (H12 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (apart_point_and_line X Y) (logic.or (distinct_lines Y Z) (apart_point_and_line X Z)))))))))) => (H13 : (logic.prf (logic.forall (X: logic.Term => (logic.forall (Y: logic.Term => (logic.forall (Z: logic.Term => (logic.imply (convergent_lines X Y) (logic.or (distinct_lines Y Z) (convergent_lines X Z)))))))))) => (v0:logic.Term => (v1:logic.Term => (v2:logic.Term => (H14 : (logic.prf (logic.and (convergent_lines v0 v1) (logic.and (logic.not (apart_point_and_line v2 v0)) (logic.not (apart_point_and_line v2 v1))))) => (H15 : (logic.prf (distinct_points v2 (intersection_point v0 v1))) => (H14 logic.False (H16 : (logic.prf (convergent_lines v0 v1)) => H17 : (logic.prf (logic.and (logic.not (apart_point_and_line v2 v0)) (logic.not (apart_point_and_line v2 v1)))) => (H17 logic.False (H18 : (logic.prf (logic.not (apart_point_and_line v2 v0))) => H19 : (logic.prf (logic.not (apart_point_and_line v2 v1))) => (((((H13 v0) v1) v0) H16) logic.False (H20 : (logic.prf (distinct_lines v1 v0)) => ((((((H10 v2) (intersection_point v0 v1)) v1) v0) (P24 : logic.Prop => H25 : ((logic.prf (distinct_points v2 (intersection_point v0 v1))) -> (logic.prf (distinct_lines v1 v0)) -> logic.prf P24) => H25 H15 H20)) logic.False (H22 : (logic.prf (apart_point_and_line v2 v1)) => (H19 H22)) (H23 : (logic.prf (logic.or (apart_point_and_line v2 v0) (logic.or (apart_point_and_line (intersection_point v0 v1) v1) (apart_point_and_line (intersection_point v0 v1) v0)))) => (H23 logic.False (H26 : (logic.prf (apart_point_and_line v2 v0)) => (H18 H26)) (H27 : (logic.prf (logic.or (apart_point_and_line (intersection_point v0 v1) v1) (apart_point_and_line (intersection_point v0 v1) v0))) => (H27 logic.False (H28 : (logic.prf (apart_point_and_line (intersection_point v0 v1) v1)) => ((((H9 v0) v1) H16) H28)) (H29 : (logic.prf (apart_point_and_line (intersection_point v0 v1) v0)) => ((((H8 v0) v1) H16) H29)))))))) (H21 : (logic.prf (convergent_lines v0 v0)) => ((H2 v0) H21)))))))))))))))))))))))))).
#NAME KRS131_431todk.
cnotA : logic.Term -> logic.Prop.
cNothing : logic.Term -> logic.Prop.
cowlNothing : logic.Term -> logic.Prop.
cA : logic.Term -> logic.Prop.
cowlThing : logic.Term -> logic.Prop.
rq : logic.Term -> logic.Term -> logic.Prop.
xsd_integer : logic.Term -> logic.Prop.
rp : logic.Term -> logic.Term -> logic.Prop.
xsd_string : logic.Term -> logic.Prop.
conjecture_proof : (logic.prf (logic.imply (logic.forall (X: logic.Term => (logic.and (cowlThing X) (logic.not (cowlNothing X))))) (logic.imply (logic.forall (X: logic.Term => (logic.equiv (xsd_string X) (logic.not (xsd_integer X))))) (logic.imply (logic.forall (X: logic.Term => (logic.and (logic.imply (logic.not (logic.not (cA X))) (logic.exists (Y: logic.Term => (logic.and (rq X Y) (cowlThing Y))))) (logic.imply (logic.exists (Y: logic.Term => (logic.and (rq X Y) (cowlThing Y)))) (cA X))))) (logic.imply (logic.forall (X: logic.Term => (logic.imply (cNothing X) (logic.not (logic.exists (Y: logic.Term => (rp X Y))))))) (logic.imply (logic.forall (X: logic.Term => (logic.imply (cNothing X) (logic.exists (Y: logic.Term => (rp X Y)))))) (logic.imply (logic.forall (X: logic.Term => (logic.and (logic.imply (logic.not (logic.not (cnotA X))) (logic.forall (Y: logic.Term => (logic.imply (rq X Y) (cNothing Y))))) (logic.imply (logic.forall (Y: logic.Term => (logic.imply (rq X Y) (cNothing Y)))) (cnotA X))))) (logic.and (logic.forall (X: logic.Term => (logic.and (cowlThing X) (logic.not (cowlNothing X))))) (logic.and (logic.forall (X: logic.Term => (logic.equiv (xsd_string X) (logic.not (xsd_integer X))))) (logic.forall (X: logic.Term => (logic.and (logic.imply (cnotA X) (logic.not (cA X))) (logic.imply (logic.not (cA X)) (logic.not (logic.not (cnotA X)))))))))))))))) :=
H0: (logic.prf (logic.forall (X: logic.Term => (logic.and (cowlThing X) (logic.not (cowlNothing X)))))) => (H1: (logic.prf (logic.forall (X: logic.Term => (logic.equiv (xsd_string X) (logic.not (xsd_integer X)))))) => (H2: (logic.prf (logic.forall (X: logic.Term => (logic.and (logic.imply (logic.not (logic.not (cA X))) (logic.exists (Y: logic.Term => (logic.and (rq X Y) (cowlThing Y))))) (logic.imply (logic.exists (Y: logic.Term => (logic.and (rq X Y) (cowlThing Y)))) (cA X)))))) => (H3: (logic.prf (logic.forall (X: logic.Term => (logic.imply (cNothing X) (logic.not (logic.exists (Y: logic.Term => (rp X Y)))))))) => (H4: (logic.prf (logic.forall (X: logic.Term => (logic.imply (cNothing X) (logic.exists (Y: logic.Term => (rp X Y))))))) => (H5: (logic.prf (logic.forall (X: logic.Term => (logic.and (logic.imply (logic.not (logic.not (cnotA X))) (logic.forall (Y: logic.Term => (logic.imply (rq X Y) (cNothing Y))))) (logic.imply (logic.forall (Y: logic.Term => (logic.imply (rq X Y) (cNothing Y)))) (cnotA X)))))) => (P6: logic.Prop => (H7: ((logic.prf (logic.forall (X: logic.Term => (logic.and (cowlThing X) (logic.not (cowlNothing X)))))) -> ((logic.prf (logic.and (logic.forall (X: logic.Term => (logic.equiv (xsd_string X) (logic.not (xsd_integer X))))) (logic.forall (X: logic.Term => (logic.and (logic.imply (cnotA X) (logic.not (cA X))) (logic.imply (logic.not (cA X)) (logic.not (logic.not (cnotA X))))))))) -> (logic.prf P6))) => (H7 H0 (P8: logic.Prop => (H9: ((logic.prf (logic.forall (X: logic.Term => (logic.equiv (xsd_string X) (logic.not (xsd_integer X)))))) -> ((logic.prf (logic.forall (X: logic.Term => (logic.and (logic.imply (cnotA X) (logic.not (cA X))) (logic.imply (logic.not (cA X)) (logic.not (logic.not (cnotA X)))))))) -> (logic.prf P8))) => (H9 H1 (v0: logic.Term => (P10: logic.Prop => (H11: ((logic.prf (logic.imply (cnotA v0) (logic.not (cA v0)))) -> ((logic.prf (logic.imply (logic.not (cA v0)) (logic.not (logic.not (cnotA v0))))) -> (logic.prf P10))) => (H11 (H27: (logic.prf (cnotA v0)) => (H28: (logic.prf (cA v0)) => ((H5 v0) logic.False (H29: (logic.prf (logic.imply (logic.not (logic.not (cnotA v0))) (logic.forall (Y: logic.Term => (logic.imply (rq v0 Y) (cNothing Y)))))) => (H30: (logic.prf (logic.imply (logic.forall (Y: logic.Term => (logic.imply (rq v0 Y) (cNothing Y)))) (cnotA v0))) => ((H2 v0) logic.False (H32: (logic.prf (logic.imply (logic.not (logic.not (cA v0))) (logic.exists (Y: logic.Term => (logic.and (rq v0 Y) (cowlThing Y)))))) => (H33: (logic.prf (logic.imply (logic.exists (Y: logic.Term => (logic.and (rq v0 Y) (cowlThing Y)))) (cA v0))) => ((H32 (H34: (logic.prf (logic.not (cA v0))) => (H34 (H33 ((H34 H28) (logic.exists (Y: logic.Term => (logic.and (rq v0 Y) (cowlThing Y))))))))) logic.False (v2: logic.Term => (H35: (logic.prf (logic.and (rq v0 v2) (cowlThing v2))) => (H35 logic.False (H36: (logic.prf (rq v0 v2)) => (H37: (logic.prf (cowlThing v2)) => (((H3 v2) (((H29 (H31: (logic.prf (logic.not (cnotA v0))) => (H31 (H30 ((H31 H27) (logic.forall (Y: logic.Term => (logic.imply (rq v0 Y) (cNothing Y))))))))) v2) H36)) ((H4 v2) (((H29 (H31: (logic.prf (logic.not (cnotA v0))) => (H31 (H30 ((H31 H27) (logic.forall (Y: logic.Term => (logic.imply (rq v0 Y) (cNothing Y))))))))) v2) H36))))))))))))))))) (H12: (logic.prf (logic.not (cA v0))) => ((H5 v0) (logic.not (logic.not (cnotA v0))) (H13: (logic.prf (logic.imply (logic.not (logic.not (cnotA v0))) (logic.forall (Y: logic.Term => (logic.imply (rq v0 Y) (cNothing Y)))))) => (H14: (logic.prf (logic.imply (logic.forall (Y: logic.Term => (logic.imply (rq v0 Y) (cNothing Y)))) (cnotA v0))) => (H15: (logic.prf (logic.not (cnotA v0))) => (H15 (H14 (H13 (H16: (logic.prf (logic.not (cnotA v0))) => (H16 ((H16 (H14 (v1: logic.Term => (H17: (logic.prf (rq v0 v1)) => (((H2 v0) logic.False (H18: (logic.prf (logic.imply (logic.not (logic.not (cA v0))) (logic.exists (Y: logic.Term => (logic.and (rq v0 Y) (cowlThing Y)))))) => (H19: (logic.prf (logic.imply (logic.exists (Y: logic.Term => (logic.and (rq v0 Y) (cowlThing Y)))) (cA v0))) => (H12 (H19 (H18 (H20: (logic.prf (logic.not (cA v0))) => (H20 ((H20 (H19 ((H0 v1) (logic.exists (Y: logic.Term => (logic.and (rq v0 Y) (cowlThing Y)))) (H21: (logic.prf (cowlThing v1)) => (H22: (logic.prf (logic.not (cowlNothing v1))) => (P23: logic.Prop => (H24: (Y: logic.Term -> ((logic.prf (logic.and (rq v0 Y) (cowlThing Y))) -> (logic.prf P23))) => (H24 v1 (P25: logic.Prop => (H26: ((logic.prf (rq v0 v1)) -> ((logic.prf (cowlThing v1)) -> (logic.prf P25))) => (H26 H17 H21))))))))))) (cA v0)))))))))) (cNothing v1)))))) (cnotA v0))))))))))))))))))))))))))).
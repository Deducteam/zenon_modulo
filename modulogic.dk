#NAME zen.

prop  : Type.
proof : prop -> Type.
type  : Type.
term  : type -> Type.

True  : prop.
False : prop.

not : prop -> prop.
and : prop -> prop -> prop.
or  : prop -> prop -> prop.
imp : prop -> prop -> prop.
eqv : prop -> prop -> prop.

forall : a : type -> (term a -> prop) -> prop.
exists : a : type -> (term a -> prop) -> prop.

foralltype : (type -> prop) -> prop.
existstype : (type -> prop) -> prop.

equal  : a : type -> term a -> term a -> prop.
seq : Type.

(; LLproof deduction rules ;)

Rfalse         : proof False -> seq.

Rnottrue       : proof (not True) -> seq.

Raxiom         : p : prop -> 
	         proof p -> proof (not p) -> seq.

Rnoteq         : a : type -> t : term a -> 
	         proof (not (equal a t t)) -> seq.

Reqsym         : a : type -> t : term a -> u : term a -> 
	         proof (equal a t u) -> proof (not (equal a u t)) -> seq.

Rcut           : p : prop -> 
	         (proof p -> seq) -> 
	         (proof (not p) -> seq) -> 
	         seq.

Rnotnot        : p : prop -> 
	         (proof p -> seq) -> 
	         proof (not (not p)) -> seq.

Rand           : p : prop -> q : prop -> 
	         (proof p -> proof q -> seq) -> 
	         proof (and p q) -> seq.

Ror            : p : prop -> q : prop -> 
	         (proof p -> seq) -> 
	         (proof q -> seq) -> 
	         proof (or p q) -> seq.

Rimply         : p : prop -> q : prop -> 
	         (proof (not p) -> seq) -> 
	         (proof q -> seq) -> 
	         proof (imp p q) -> seq.

Requiv         : p : prop -> q : prop -> 
	         (proof (not p) -> proof (not q) -> seq) -> 
	         (proof p -> proof q -> seq) -> 
	         proof (eqv p q) -> seq.

Rnotand        : p : prop -> q : prop -> 
	         (proof (not p) -> seq) -> 
	         (proof (not q) -> seq) -> 
	         proof (not (and p q)) -> seq.

Rnotor         : p : prop -> q : prop -> 
	         (proof (not p) -> proof (not q) -> seq) -> 
	         proof (not (or p q)) -> seq.

Rnotimply      : p : prop -> q : prop -> 
	         (proof p -> proof (not q) -> seq) -> 
	         proof (not (imp p q)) -> seq.

Rnotequiv      : p : prop -> q : prop -> 
	         (proof (not p) -> proof q -> seq) -> 
	         (proof p -> proof (not q) -> seq) -> 
	         proof (not (eqv p q)) -> seq.

Rex            : a : type -> p : (term a -> prop) -> 
	         (t : term a -> proof (p t) -> seq) -> 
	         proof (exists a p) -> seq.

Rall           : a : type -> p : (term a -> prop) -> t : term a -> 
	         (proof (p t) -> seq) -> 
	         proof (forall a p) -> seq.

Rnotex         : a : type -> p : (term a -> prop) -> t : term a -> 
	         (proof (not (p t)) -> seq) -> 
	         proof (not (exists a p)) -> seq.

Rnotall        : a : type -> p : (term a -> prop) -> 
	         (t : term a -> proof (not (p t)) -> seq) -> 
	         proof (not (forall a p)) -> seq.

Rextype        : p : (type -> prop) -> 
	         (a : type -> proof (p a) -> seq) -> 
	         proof (existstype p) -> seq.

Ralltype       : p : (type -> prop) -> a : type -> 
	         (proof (p a) -> seq) -> 
	         proof (foralltype p) -> seq.

Rnotextype     : p : (type -> prop) -> a : type -> 
	         (proof (not (p a)) -> seq) -> 
	         proof (not (existstype p)) -> seq.

Rnotalltype    : p : (type -> prop) -> 
	         (a : type -> proof (not (p a)) -> seq) -> 
	         proof (not (foralltype p)) -> seq.

Rsubst         : a : type -> p : (term a -> prop) -> t1 : term a -> t2 : term a -> 
                 (proof (not (equal a t1 t2)) -> seq) -> 
		 (proof (p t2) -> seq) -> 
		 proof (p t1) -> seq.

Rconglr        : a : type -> p : (term a -> prop) -> t1 : term a -> t2 : term a -> 
	         (proof (p t2) -> seq) -> 
	         proof (p t1) -> proof (equal a t1 t2) -> seq.

Rcongrl        : a : type -> p : (term a -> prop) -> t1 : term a -> t2 : term a -> 
	         (proof (p t2) -> seq) -> 
	         proof (p t1) -> proof (equal a t2 t1) -> seq.


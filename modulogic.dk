#NAME zen.

(; Logic for Zenon Modulo ;)

prop  : Type.
proof : prop -> Type.
type  : Type.
term  : type -> Type.
iota  : type.

(; Symbols ;)

True  : prop.
False : prop.

not : prop -> prop.
and : prop -> prop -> prop.
or  : prop -> prop -> prop.
imp : prop -> prop -> prop.
eqv : prop -> prop -> prop.

forall : a : type -> (term a -> prop) -> prop.
exists : a : type -> (term a -> prop) -> prop.

foralltype : (type -> prop) -> prop.
existstype : (type -> prop) -> prop.

equal      : a : type -> term a -> term a -> prop.

(; Definition of Proofs of Symbols ;)

[] proof True  
      --> p : prop -> proof p -> proof p.

[] proof False 
      --> p : prop -> proof p.

[p : prop] proof (not p) 
      --> proof p -> proof False.

[p : prop, q : prop] proof (and p q) 
      --> z : prop -> 
	  (proof p -> proof q -> proof z) -> 
	  proof z.

[p : prop, q : prop] proof (or p q) 
      --> z : prop -> 
	  (proof p -> proof z) -> 
	  (proof q -> proof z) -> 
	  proof z.

[p : prop, q : prop] proof (imp p q)
      --> proof p -> proof q.

[p : prop, q : prop] proof (eqv p q) 
      --> proof (and (imp p q) (imp q p)).

[a : type, p : term a -> prop] proof (forall a p) 
      --> x : term a -> proof (p x).

[a : type, p : term a -> prop] proof (exists a p) 
      --> z : prop -> 
	  (x : term a -> proof (p x) -> proof z) -> 
	  proof z.

[p : type -> prop] proof (foralltype p) 
      --> a : type -> proof (p a).

[p : type -> prop] proof (existstype p) 
      --> z : prop -> 
	  (a : type -> proof (p a) -> proof z) -> 
	  proof z.

[a : type, x : term a, y : term a] proof (equal a x y) 
      --> z : (term a -> prop) -> 
	  proof (z x) -> proof (z y).

(; The Sequent Type ;)

seq        : Type.

[] seq 
      --> proof False.

(; Law of Excluded Middle ;)

xmid       : p : prop -> 
	     z : prop -> 
	     (proof p -> proof z) -> 
	     (proof (not p) -> proof z) -> 
	     proof z.

nnpp       : p : prop -> 
	     proof (not (not p)) -> proof p.

[p : prop] nnpp p 
      --> H1 : proof (not (not p)) 
	  => xmid p p 
		  (H2 : proof p 
		   => H2) 
		  (H3 : proof (not p) 
		   => H1 H3 p).

(; LLproof Deduction Rules ;)

Rfalse         : proof False -> seq.

Rnottrue       : proof (not True) -> seq.

Raxiom         : p : prop -> 
	         proof p -> proof (not p) -> seq.

Rnoteq         : a : type -> t : term a -> 
	         proof (not (equal a t t)) -> seq.

Reqsym         : a : type -> t : term a -> u : term a -> 
	         proof (equal a t u) -> proof (not (equal a u t)) -> seq.

Rcut           : p : prop -> 
	         (proof p -> seq) -> 
	         (proof (not p) -> seq) -> 
	         seq.

Rnotnot        : p : prop -> 
	         (proof p -> seq) -> 
	         proof (not (not p)) -> seq.

Rand           : p : prop -> q : prop -> 
	         (proof p -> proof q -> seq) -> 
	         proof (and p q) -> seq.

Ror            : p : prop -> q : prop -> 
	         (proof p -> seq) -> 
	         (proof q -> seq) -> 
	         proof (or p q) -> seq.

Rimply         : p : prop -> q : prop -> 
	         (proof (not p) -> seq) -> 
	         (proof q -> seq) -> 
	         proof (imp p q) -> seq.

Requiv         : p : prop -> q : prop -> 
	         (proof (not p) -> proof (not q) -> seq) -> 
	         (proof p -> proof q -> seq) -> 
	         proof (eqv p q) -> seq.

Rnotand        : p : prop -> q : prop -> 
	         (proof (not p) -> seq) -> 
	         (proof (not q) -> seq) -> 
	         proof (not (and p q)) -> seq.

Rnotor         : p : prop -> q : prop -> 
	         (proof (not p) -> proof (not q) -> seq) -> 
	         proof (not (or p q)) -> seq.

Rnotimply      : p : prop -> q : prop -> 
	         (proof p -> proof (not q) -> seq) -> 
	         proof (not (imp p q)) -> seq.

Rnotequiv      : p : prop -> q : prop -> 
	         (proof (not p) -> proof q -> seq) -> 
	         (proof p -> proof (not q) -> seq) -> 
	         proof (not (eqv p q)) -> seq.

Rex            : a : type -> p : (term a -> prop) -> 
	         (t : term a -> proof (p t) -> seq) -> 
	         proof (exists a p) -> seq.

Rall           : a : type -> p : (term a -> prop) -> t : term a -> 
	         (proof (p t) -> seq) -> 
	         proof (forall a p) -> seq.

Rnotex         : a : type -> p : (term a -> prop) -> t : term a -> 
	         (proof (not (p t)) -> seq) -> 
	         proof (not (exists a p)) -> seq.

Rnotall        : a : type -> p : (term a -> prop) -> 
	         (t : term a -> proof (not (p t)) -> seq) -> 
	         proof (not (forall a p)) -> seq.

Rextype        : p : (type -> prop) -> 
	         (a : type -> proof (p a) -> seq) -> 
	         proof (existstype p) -> seq.

Ralltype       : p : (type -> prop) -> a : type -> 
	         (proof (p a) -> seq) -> 
	         proof (foralltype p) -> seq.

Rnotextype     : p : (type -> prop) -> a : type -> 
	         (proof (not (p a)) -> seq) -> 
	         proof (not (existstype p)) -> seq.

Rnotalltype    : p : (type -> prop) -> 
	         (a : type -> proof (not (p a)) -> seq) -> 
	         proof (not (foralltype p)) -> seq.

Rsubst         : a : type -> p : (term a -> prop) -> t1 : term a -> t2 : term a -> 
                 (proof (not (equal a t1 t2)) -> seq) -> 
		 (proof (p t2) -> seq) -> 
		 proof (p t1) -> seq.

Rconglr        : a : type -> p : (term a -> prop) -> t1 : term a -> t2 : term a -> 
	         (proof (p t2) -> seq) -> 
	         proof (p t1) -> proof (equal a t1 t2) -> seq.

Rcongrl        : a : type -> p : (term a -> prop) -> t1 : term a -> t2 : term a -> 
	         (proof (p t2) -> seq) -> 
	         proof (p t1) -> proof (equal a t2 t1) -> seq.


(; Proofs of Deduction Rules ;)

true_intro : proof True. 

[] true_intro 
      --> p : prop 
	  => x : proof p
	     => x.

[] Rfalse 
      --> x : proof False 
	  => x.

[] Rnottrue 
      --> H : proof (not True) 
	  => H true_intro.

[p : prop] Raxiom p 
      --> H : proof p 
	  => CH : proof (not p) 
	     => CH H.

[a : type, t : term a] Rnoteq a t 
      --> H1 : proof (not (equal a t t)) 
	  => H1 (z : (term a -> prop) 
		 => (H2 : proof (z t) 
		     => H2)).

[a : type, t : term a, u : term a] Reqsym a t u 
      --> H1 : proof (equal a t u) 
	  => H2 : proof (not (equal a u t)) 
	     => H2 (z : (term a -> prop) 
		    => H3 : proof (z u)
		       => H1 (x : term a 
			      => (imp (z x) (z t))) 
			     (H4 : proof (z t) 
			      => H4)
			     H3).

[p : prop] Rcut p
      --> H1 : (proof p -> proof False) 
	  => H2 : (proof (not p) -> proof False) 
	     => H2 H1.

[p : prop] Rnotnot p 
      --> H1 : (proof p -> proof False) 
	  => H2 : proof (not (not p)) 
	     => H2 H1.

[p : prop, q : prop] Rand p q 
      --> H1 : (proof p -> proof q -> proof False) 
	  => H2 : proof (and p q) 
	     => H2 False H1.

[p : prop, q : prop] Ror p q 
      --> H1 : (proof p -> proof False) 
	  => H2 : (proof q -> proof False) 
	     => H3 : proof (or p q) 
		=> H3 False H1 H2.

lemme_imp : p : prop -> q : prop -> 
	    proof (imp p q) -> 
	    proof (imp (not q) (not p)).

[p : prop, q : prop] lemme_imp p q 
      --> H1 : proof (imp p q) 
	  => H2 : proof (not q) 
	     => H3 : proof p 
		=> H2 (H1 H3).

[p : prop, q : prop] Rimply p q 
      --> H1 : (proof (not p) -> proof False) 
	  => H2 : (proof q -> proof False) 
	     => H3 : proof (imp p q) 
		=> H1 (lemme_imp p q H3 H2).

lemme_1 (p : prop) 
	(q : prop) 
	(H5 : proof q -> proof p) 
	(H2 : proof p -> proof (not q)) 
	(HQ : proof q) 
	: proof (not q)
:= 
  H2 (H5 HQ).

lemme_2 (p : prop) 
	(q : prop) 
	(H5 : proof q -> proof p) 
	(H2 : proof p -> proof (not q)) 
	: proof (not q)
:= 
  HQ : proof q 
  => lemme_1 p q H5 H2 HQ HQ.

lemme_3 (p : prop) 
	(q : prop) 
	(H5 : proof q -> proof p) 
	(H2 : proof p -> proof (not q)) 
	(H4 : proof p -> proof q)
	: proof (not p)
:= 
  lemme_imp p q H4 (lemme_2 p q H5 H2).

lemme_4 (p : prop) 
	(q : prop) 
	(H5 : proof q -> proof p) 
	(H2 : proof p -> proof (not q)) 
	(H4 : proof p -> proof q) 
	(H1 : proof (not p) -> proof (not (not q)))
	: proof (not (not q))
:= 
  H1 (lemme_3 p q H5 H2 H4).

[p : prop, q : prop] Requiv p q 
      --> H1 : (proof (not p) -> proof (not q) -> proof False) 
	  => H2 : (proof p -> proof q -> proof False) 
	     => H3 : proof (eqv p q) 
		=> H3 False (H4 : (proof p -> proof q)
			     => H5 : (proof q -> proof p) 
				=> lemme_4 p q H5 H2 H4 H1 (lemme_2 p q H5 H2)).

(;[p : prop, q : prop] Rnotand p q 
      --> H1 : (proof (not p) -> proof False) 
	  => H2 : (proof (not q) -> proof False) 
	     => H3 : proof (not (and p q)) 
		=> H3 ;)
(;
[a : type, p : (term a -> prop)] Rex a p 
      --> H1 : (t : term a -> proof (p t) -> proof False) 
	  => H2 : proof (exists a p) 
	     => H2 False H1.;)
(;
[a : type, p : (term a -> prop), t : term a] Rall a p t 
      --> H1 : (proof (p t) -> proof False) 
	  => H2 : proof (forall a p) 
	     => H1 (H2 t).;)

(;[a : type, p : (term a -> prop), t : term a] Rnotex a p t 
      --> H1 : (proof (not (p t)) -> proof False) 
	  => H2 : proof (not (exists a p)) 
	     => H2 .;)
(;
[a : type, p : (term a -> prop), t1 : term a, t2 : term a] Rsubst a p t1 t2 
      --> H1 : (proof (not (equal a t1 t2)) -> proof False) 
	  => H2 : (proof (p t2) -> proof False) 
	     => H3 : proof (p t1) 
		=> ;)
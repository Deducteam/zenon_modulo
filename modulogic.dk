#NAME zen.

(; Logic for Zenon Modulo ;)

prop  : Type := dk_logic.Prop.
proof : prop -> Type := dk_logic.eP.
type  : Type := cc.uT.
term  : type -> Type := cc.eT.
iota  : type.

(; Symbols ;)

True  : prop := dk_logic.True.
False : prop := dk_logic.False.

not : prop -> prop := dk_logic.not.
and : prop -> prop -> prop := dk_logic.and.
or  : prop -> prop -> prop := dk_logic.or.
imp : prop -> prop -> prop := dk_logic.imp.
eqv : prop -> prop -> prop := dk_logic.eqv.

forall : a : type -> (term a -> prop) -> prop := dk_logic.forall.
exists : a : type -> (term a -> prop) -> prop := dk_logic.exists.

foralltype : (type -> prop) -> prop := dk_logic.forall_type.
existstype : (type -> prop) -> prop := dk_logic.exists_type.

equal      : a : type -> term a -> term a -> prop := dk_logic.equal.

(; Definition of Proofs of Symbols ;)

(; The Sequent Type ;)

seq        : Type.

[] seq
      --> proof False.

(; Law of Excluded Middle ;)

xmid       : p : prop ->
	     z : prop ->
	     (proof p -> proof z) ->
	     (proof (not p) -> proof z) ->
	     proof z.

nnpp       : p : prop ->
	     proof (not (not p)) -> proof p.

[p : prop] nnpp p
      --> H1 : proof (not (not p))
	  => xmid p p
		  (H2 : proof p
		   => H2)
		  (H3 : proof (not p)
		   => H1 H3 p).

(; LLproof Deduction Rules ;)

Rfalse         : proof False -> seq.

Rnottrue       : proof (not True) -> seq.

Raxiom         : p : prop ->
	         proof p -> proof (not p) -> seq.

Rnoteq         : a : type -> t : term a ->
	         proof (not (equal a t t)) -> seq.

Reqsym         : a : type -> t : term a -> u : term a ->
	         proof (equal a t u) -> proof (not (equal a u t)) -> seq.

Rcut           : p : prop ->
	         (proof p -> seq) ->
	         (proof (not p) -> seq) ->
	         seq.

Rnotnot        : p : prop ->
	         (proof p -> seq) ->
	         proof (not (not p)) -> seq.

Rand           : p : prop -> q : prop ->
	         (proof p -> proof q -> seq) ->
	         proof (and p q) -> seq.

Ror            : p : prop -> q : prop ->
	         (proof p -> seq) ->
	         (proof q -> seq) ->
	         proof (or p q) -> seq.

Rimply         : p : prop -> q : prop ->
	         (proof (not p) -> seq) ->
	         (proof q -> seq) ->
	         proof (imp p q) -> seq.

Requiv         : p : prop -> q : prop ->
	         (proof (not p) -> proof (not q) -> seq) ->
	         (proof p -> proof q -> seq) ->
	         proof (eqv p q) -> seq.

Rnotand        : p : prop -> q : prop ->
	         (proof (not p) -> seq) ->
	         (proof (not q) -> seq) ->
	         proof (not (and p q)) -> seq.

Rnotor         : p : prop -> q : prop ->
	         (proof (not p) -> proof (not q) -> seq) ->
	         proof (not (or p q)) -> seq.

Rnotimply      : p : prop -> q : prop ->
	         (proof p -> proof (not q) -> seq) ->
	         proof (not (imp p q)) -> seq.

Rnotequiv      : p : prop -> q : prop ->
	         (proof (not p) -> proof q -> seq) ->
	         (proof p -> proof (not q) -> seq) ->
	         proof (not (eqv p q)) -> seq.

Rex            : a : type -> p : (term a -> prop) ->
	         (t : term a -> proof (p t) -> seq) ->
	         proof (exists a p) -> seq.

Rall           : a : type -> p : (term a -> prop) -> t : term a ->
	         (proof (p t) -> seq) ->
	         proof (forall a p) -> seq.

Rnotex         : a : type -> p : (term a -> prop) -> t : term a ->
	         (proof (not (p t)) -> seq) ->
	         proof (not (exists a p)) -> seq.

Rnotall        : a : type -> p : (term a -> prop) ->
	         (t : term a -> proof (not (p t)) -> seq) ->
	         proof (not (forall a p)) -> seq.

Rextype        : p : (type -> prop) ->
	         (a : type -> proof (p a) -> seq) ->
	         proof (existstype p) -> seq.

Ralltype       : p : (type -> prop) -> a : type ->
	         (proof (p a) -> seq) ->
	         proof (foralltype p) -> seq.

Rnotextype     : p : (type -> prop) -> a : type ->
	         (proof (not (p a)) -> seq) ->
	         proof (not (existstype p)) -> seq.

Rnotalltype    : p : (type -> prop) ->
	         (a : type -> proof (not (p a)) -> seq) ->
	         proof (not (foralltype p)) -> seq.

Rsubst         : a : type -> p : (term a -> prop) -> t1 : term a -> t2 : term a ->
                 (proof (not (equal a t1 t2)) -> seq) ->
		 (proof (p t2) -> seq) ->
		 proof (p t1) -> seq.

Rconglr        : a : type -> p : (term a -> prop) -> t1 : term a -> t2 : term a ->
	         (proof (p t2) -> seq) ->
	         proof (p t1) -> proof (equal a t1 t2) -> seq.

Rcongrl        : a : type -> p : (term a -> prop) -> t1 : term a -> t2 : term a ->
	         (proof (p t2) -> seq) ->
	         proof (p t1) -> proof (equal a t2 t1) -> seq.


(; Proofs of Deduction Rules ;)

true_intro : proof True.

[] true_intro
      --> p : prop
	  => x : proof p
	     => x.

[] Rfalse
      --> x : proof False
	  => x.

[] Rnottrue
      --> H : proof (not True)
	  => H true_intro.

[p : prop] Raxiom p
      --> H : proof p
	  => CH : proof (not p)
	     => CH H.

[a : type, t : term a] Rnoteq a t
      --> H1 : proof (not (equal a t t))
	  => H1 (z : (term a -> prop)
		 => (H2 : proof (z t)
		     => H2)).

[a : type, t : term a, u : term a] Reqsym a t u
      --> H1 : proof (equal a t u)
	  => H2 : proof (not (equal a u t))
	     => H2 (z : (term a -> prop)
		    => H3 : proof (z u)
		       => H1 (x : term a
			      => (imp (z x) (z t)))
			     (H4 : proof (z t)
			      => H4)
			     H3).

[p : prop] Rcut p
      --> H1 : (proof p -> proof False)
	  => H2 : (proof (not p) -> proof False)
	     => H2 H1.

[p : prop] Rnotnot p
      --> H1 : (proof p -> proof False)
	  => H2 : proof (not (not p))
	     => H2 H1.

[p : prop, q : prop] Rand p q
      --> H1 : (proof p -> proof q -> proof False)
	  => H2 : proof (and p q)
	     => H2 False H1.

[p : prop, q : prop] Ror p q
      --> H1 : (proof p -> proof False)
	  => H2 : (proof q -> proof False)
	     => H3 : proof (or p q)
		=> H3 False H1 H2.

lemme_imp : p : prop -> q : prop ->
	    proof (imp p q) ->
	    proof (imp (not q) (not p)).

[p : prop, q : prop] lemme_imp p q
      --> H1 : proof (imp p q)
	  => H2 : proof (not q)
	     => H3 : proof p
		=> H2 (H1 H3).

[p : prop, q : prop] Rimply p q
      --> H1 : (proof (not p) -> proof False)
	  => H2 : (proof q -> proof False)
	     => H3 : proof (imp p q)
		=> H1 (lemme_imp p q H3 H2).

lemme_1 (p : prop)
	(q : prop)
	(H5 : proof q -> proof p)
	(H2 : proof p -> proof (not q))
	(HQ : proof q)
	: proof (not q)
:=
  H2 (H5 HQ).

lemme_2 (p : prop)
	(q : prop)
	(H5 : proof q -> proof p)
	(H2 : proof p -> proof (not q))
	: proof (not q)
:=
  HQ : proof q
  => lemme_1 p q H5 H2 HQ HQ.

lemme_3 (p : prop)
	(q : prop)
	(H5 : proof q -> proof p)
	(H2 : proof p -> proof (not q))
	(H4 : proof p -> proof q)
	: proof (not p)
:=
  lemme_imp p q H4 (lemme_2 p q H5 H2).

lemme_4 (p : prop)
	(q : prop)
	(H5 : proof q -> proof p)
	(H2 : proof p -> proof (not q))
	(H4 : proof p -> proof q)
	(H1 : proof (not p) -> proof (not (not q)))
	: proof (not (not q))
:=
  H1 (lemme_3 p q H5 H2 H4).

[p : prop, q : prop] Requiv p q
      --> H1 : (proof (not p) -> proof (not q) -> proof False)
	  => H2 : (proof p -> proof q -> proof False)
	     => H3 : proof (eqv p q)
		=> H3 False (H4 : (proof p -> proof q)
			     => H5 : (proof q -> proof p)
				=> lemme_4 p q H5 H2 H4 H1 (lemme_2 p q H5 H2)).

[p : prop, q : prop] Rnotand p q
      --> H1 : (proof (not p) -> proof False)
	  => H2 : (proof (not q) -> proof False)
	     => H3 : proof (not (and p q))
		=> H3 (z : prop 
		       => H4 : (proof p -> proof q -> proof z) 
			  => H4 (nnpp p H1) (nnpp q H2)).

lemme_5 : p : prop -> 
	  q : prop -> 
	  proof p -> proof (or p q).

[p : prop, q : prop] lemme_5 p q 
      --> H1 : proof p 
	  => z : prop 
	     => H2 : (proof p -> proof z) 
		=> H3 : (proof q -> proof z) 
		   => H2 H1.

lemme_6 (p : prop)
	(q : prop)
	(H2 : proof (not (or p q)))
	: proof (not p)
:=
  lemme_imp p (or p q) (lemme_5 p q) H2.

lemme_7 (p : prop)
	(q : prop)
	(H2 : proof (not (or p q)))
	: proof (not q)
:=
  lemme_imp p (or p q) (lemme_5 p q) H2.

[p : prop, q : prop] Rnotor p q 
      --> H1 : (proof (not p) -> proof (not q) -> proof False)
	  => H2 : proof (not (or p q)) 
	     => H1 (lemme_6 p q H2) (lemme_7 p q H2).

lemme_8 (p : prop) 
	(q : prop) 
	(H2 : proof (not (imp p q)))
	: proof (not q)
:=
  H3 : proof q 
  => H2 (H4 : proof p  
	 => H3).

lemme_9 (p : prop) 
	(q : prop) 
	(H1 : proof p -> proof (not (not q)))
	(H2 : proof (not (imp p q)))
	: proof (not p)
:=
  H3 : proof p 
  => (H1 H3) (lemme_8 p q H2).

lemme_10 (p : prop) 
	 (q : prop) 
	 (H3 : proof (not p)) 
	 : proof (imp p q)
:= 
  H4 : proof p 
  => H3 H4 q.

[p : prop, q : prop] Rnotimply p q 
      --> H1 : (proof p -> proof (not q) -> proof False) 
	  => H2 : proof (not (imp p q)) 
	     => H2 (lemme_10 p q (lemme_9 p q H1 H2)).

lemme_11 (p : prop) 
	 (q : prop) 
	 (H2 : proof p -> proof (not (not q))) 
	 : (proof p -> proof q)
:= 
  HP : proof p 
  => nnpp q (H2 HP).

lemme_nn (p : prop) 
	 (H1 : proof p) 
	 : proof (not (not p)) 
:= 
  H2 : (proof p -> proof False) 
  => H2 H1.

lemme_12 (p : prop) 
	 (q : prop) 
	 (H1 : proof (not p) -> proof (not q)) 
	 : (proof q -> proof p) 
:=
  HQ : proof q 
  => nnpp p (lemme_imp (not p) (not q) H1 (lemme_nn q HQ)).

[p : prop, q : prop] Rnotequiv p q 
      --> H1 : (proof (not p) -> proof q -> proof False) 
	  => H2 : (proof p -> proof (not q) -> proof False) 
	     => H3 : proof (not (eqv p q)) 
		=> H3 (z : prop 
		       => H4 : ((proof p -> proof q) -> 
				(proof q -> proof p) -> 
				proof z) 
			  => H4 (lemme_11 p q H2) (lemme_12 p q H1)).

[a : type, p : (term a -> prop)] Rex a p
      --> H1 : (t : term a -> proof (p t) -> proof False)
	  => H2 : proof (exists a p)
	     => H2 False H1.

[a : type, p : (term a -> prop), t : term a] Rall a p t
      --> H1 : (proof (p t) -> proof False)
	  => H2 : proof (forall a p)
	     => H1 (H2 t).

[a : type, p : (term a -> prop), t : term a] Rnotex a p t 
      --> H1 : (proof (not (p t)) -> proof False) 
	  => H2 : proof (not (exists a p)) 
	     => H2 (z : prop 
		    => H3 : (x : term a -> proof (p x) -> proof z) 
		       => H3 t (nnpp (p t) H1)).

[a : type, p : (term a -> prop)] Rnotall a p 
      --> H1 : (t : term a -> proof (not (p t)) -> proof False) 
	  => H2 : proof (not (forall a p)) 
	     => H2 (t : term a 
		    => nnpp (p t) (H1 t)).

[p : (type -> prop)] Rextype p 
      --> H1 : (a : type -> proof (p a) -> proof False) 
	  => H2 : proof (existstype p) 
	     => H2 False H1.

[p : (type -> prop), a : type] Ralltype p a 
      --> H1 : (proof (p a) -> proof False) 
	  => H2 : proof (foralltype p) 
	     => H1 (H2 a).

[p : (type -> prop), a : type] Rnotextype p a 
      --> H1 : (proof (not (p a)) -> proof False) 
	  => H2 : proof (not (existstype p)) 
	     => H2 (z : prop 
		    => H3 : (b : type -> proof (p b) -> proof z) 
		       => H3 a (nnpp (p a) H1)).

[p : (type -> prop)] Rnotalltype p 
      --> H1 : (a : type -> proof (not (p a)) -> proof False) 
	  => H2 : proof (not (foralltype p)) 
	     => H2 (a : type 
		    => nnpp (p a) (H1 a)).

[a : type, p : (term a -> prop), t1 : term a, t2 : term a] 
    Rsubst a p t1 t2 
      --> H1 : (proof (not (equal a t1 t2)) -> proof False) 
	  => H2 : (proof (p t2) -> proof False) 
	     => H3 : proof (p t1) 
		=> H2 ((nnpp (equal a t1 t2) H1) p H3).
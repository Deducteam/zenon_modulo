(*
; file: species_general_additive_law.foc
; species: partially_ordered_additive_monoid
; property: order_inf_reverse_order_sup / __lemma_1_1
*)
%%begin-auto-proof
%%location: []
%%name: foo
%%syntax: x
%%statement x.
(Is_true
((abst_equal
  (abst_plus (abst_inf x y ) y ) (abst_plus (abst_inf x y ) (abst_sup x y ) )
 ))
)
Parameter
  abst_equal_symmetric: forall (x: abst_T) (y: abst_T),
  ((Is_true ((abst_equal  x y)) ))-> 
    (Is_true ((abst_equal  y x)) ).
Parameter
 abst_equal_transitive: forall (x: abst_T)
  (y: abst_T) (z: abst_T),
  ((Is_true ((abst_equal  x y)) ))-> 
    ((Is_true ((abst_equal  y z)) ))-> 
      (Is_true ((abst_equal  x z)) ).
Parameter
  H_1_1: (Is_true ((abst_order_inf x y )) ).
Parameter
 abst_plus_is_left_congruence:
  forall (x: abst_T) (y: abst_T) (z: abst_T),
  ((Is_true ((abst_equal  x y)) ))-> 
    (Is_true ((abst_equal  (abst_plus  x z) (abst_plus  y z))) ).
Parameter
  abst_sum_is_inf_plus_sup: forall (x: abst_T) (y: abst_T), (Is_true
  ((abst_equal  (abst_plus  x y) (abst_plus  (abst_inf  x y) (abst_sup  x
   y))))
  ).
Definition abst_order_inf:=
 (fun (x: abst_T) => (fun (y: abst_T) => (abst_equal  x (abst_inf  x y)))).
%%end-auto-proof

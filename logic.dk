#NAME logic.
type : Type.
term : type -> Type.

Term : Type.
Prop: Type.
prf: Prop -> Type.
anyterm: Term.

not: Prop -> Prop.
notc: Prop -> Prop :=
  A:Prop => not (not (not (not (not A)))).
True: Prop.
Truec: Prop := not (not (True)).
False: Prop.
Falsec: Prop := not (not (False)).
and: Prop -> Prop -> Prop.
andc: Prop -> Prop -> Prop :=
  A:Prop => B:Prop => not (not (and (not (not A)) (not (not B)))).
or: Prop -> Prop -> Prop.
orc: Prop -> Prop -> Prop :=
  A:Prop => B:Prop => not (not (or (not (not A)) (not (not B)))).
imply: Prop -> Prop -> Prop.
implyc: Prop -> Prop -> Prop :=
  A:Prop => B:Prop => not (not (imply (not (not A)) (not (not B)))).
forall: (Term -> Prop) -> Prop.
forallc: (Term -> Prop) -> Prop :=
  P:(Term -> Prop) =>
  not (not (forall (x:Term => not (not (P x))))).
exists: (Term -> Prop) -> Prop.
existsc: (Term -> Prop) -> Prop :=
  P:(Term -> Prop) =>
  not (not (exists (x:Term => not (not (P x))))).
equal: Term -> Term -> Prop.
equalc: Term -> Term -> Prop :=
  a:Term => b:Term => not (not (equal a b)).
equiv: Prop -> Prop -> Prop :=
  A:Prop => B:Prop => and (imply A B) (imply B A).

[] prf True --> P:Prop -> (prf P -> prf P)
[] prf False --> P:Prop -> prf P
[A: Prop, B: Prop] prf (and A B) --> P:Prop -> (prf A -> prf B -> prf P) -> prf P
[A: Prop, B: Prop] prf (or A B) --> P:Prop -> (prf A -> prf P) -> (prf B -> prf P) -> prf P
[A: Prop, B: Prop] prf (imply A B) --> prf A -> prf B
[A: Prop] prf (not A) --> prf A -> prf False
[A: Term -> Prop] prf (forall A) --> x:Term -> prf (A x)
[A: Term -> Prop] prf (exists A) -->
P:Prop -> (x:Term -> prf (A x) -> prf P) -> prf P
[x: Term, y: Term] prf (equal x y) --> P:(Term -> Prop) -> prf (imply (P x) (P y)).